# 고급 상태 관리 기법: Root와 Screen 분리

이 문서는 Jetpack Compose에서 고급 상태 관리 기법, 특히 `Root`와 `Screen` 컴포저블을 분리하여 UI의 테스트 용이성과 재사용성을 높이는 방법을 설명합니다.

## 1. 기존 방식의 문제점

기존 방식은 Composable `Screen`이 `ViewModel`에 직접 의존하는 구조를 가집니다. 이로 인해 다음과 같은 문제점이 발생합니다.

-   **UI 테스트의 어려움**: `ViewModel`의 의존성을 모의(mock) 처리하기 어려워 UI 테스트 및 Preview 작성이 복잡해집니다.
-   **상태 관리 라이브러리 교체 비용 증가**: `ViewModel`과 `Screen`이 강하게 결합되어 있어, 다른 상태 관리 라이브러리로 교체하기 어렵습니다.
-   **낮은 재사용성**: 특정 `ViewModel`에 의존하는 `Screen`은 다른 컨텍스트에서 재사용하기 어렵습니다.
-   **제한적인 테스트 범위**: 화면 단위의 통합 테스트가 어려워지고, 컴포넌트 수준의 테스트만 가능해집니다.

## 2. 해결책: Root와 Screen의 분리

이러한 문제점을 해결하기 위해 `Screen`에서 외부 의존성을 분리하고, `Screen`을 순수한 UI로 유지하는 방법을 제안합니다.

-   **Screen**: 상태(`State`)와 콜백(`Callback`)만을 받아 UI를 그리는 역할에 집중합니다. `ViewModel`이나 다른 비즈니스 로직에 직접 접근하지 않습니다.
-   **Root**: `ViewModel`을 주입받고, 상태를 구독하며, 화면 이동과 같은 외부 의존성 처리를 담당하는 외부 래퍼(wrapper) 역할을 합니다.

### `Screen`에서 하면 안 되는 것들

-   `ViewModel` 인스턴스에 직접 접근
-   `Repository` 등 데이터 레이어 직접 호출
-   화면 이동 로직(Navigation) 포함
-   비즈니스 로직 포함

### 순수한 UI로서의 `Screen`

`Screen`은 오직 상태(`state`)와 이벤트 콜백(`onEvent`)만을 파라미터로 받습니다.

```kotlin
/**
 * 검색 결과를 보여주는 순수한 UI 컴포저블입니다.
 *
 * @param state 화면에 표시될 상태 (예: 레시피 목록)
 * @param onQueryChange 검색어가 변경될 때 호출되는 콜백
 * @param onSearch 검색 버튼을 클릭했을 때 호출되는 콜백
 */
@Composable
fun SearchRecipesScreen(
    state: SearchRecipesState,
    onQueryChange: (String) -> Unit,
    onSearch: () -> Unit,
) {
    // RecipeList는 상태에 따라 레시피 목록을 표시합니다.
    RecipeList(recipes = state.recipes)
    // SearchBar는 사용자 입력을 받아 콜백을 호출합니다.
    SearchBar(onQueryChange, onSearch)
}
```

## 3. Before & After: 코드 비교

### Before: `Screen`이 `ViewModel`에 직접 의존

```kotlin
/**
 * 기존 방식의 Screen 컴포저블입니다.
 * ViewModel에 직접 의존하여 상태를 관리합니다.
 *
 * @param viewModel SearchViewModel 인스턴스. 기본값으로 hiltViewModel()을 사용합니다.
 */
@Composable
fun SearchRecipesScreen(viewModel: SearchViewModel = viewModel()) {
    // viewModel로부터 상태를 직접 구독합니다.
    val state by viewModel.state.collectAsState()
    val recipes = state.filteredRecipes

    // 상태에 따라 UI를 그립니다.
    RecipeList(recipes = recipes)

    // UI 이벤트가 발생하면 viewModel의 함수를 직접 호출합니다.
    SearchBar(
        onQueryChange = { viewModel.onQueryChanged(it) }
    )
}
```

### After: `Root`와 `Screen` 분리

`Root`가 `ViewModel`과의 상호작용을 책임지고, `Screen`은 UI 렌더링에만 집중합니다.

```kotlin
/**
 * ViewModel과의 상호작용을 담당하는 Root 컴포저블입니다.
 *
 * @param viewModel SearchViewModel 인스턴스. 기본값으로 hiltViewModel()을 사용합니다.
 */
@Composable
fun SearchRecipesRoot(viewModel: SearchViewModel = viewModel()) {
    // viewModel로부터 상태를 구독합니다.
    val state by viewModel.state.collectAsState()

    // 상태와 콜백을 SearchRecipesScreen에 전달합니다.
    SearchRecipesScreen(
        state = state,
        onQueryChange = viewModel::onQueryChanged // 람다 대신 메서드 레퍼런스 사용
    )
}

/**
 * 상태와 콜백만을 받아 UI를 그리는 순수한 Screen 컴포저블입니다.
 * 이제 이 컴포저블은 Preview와 UI 테스트가 매우 용이해집니다.
 *
 * @param state 화면에 표시될 상태
 * @param onQueryChange 검색어가 변경될 때 호출되는 콜백
 */
@Composable
fun SearchRecipesScreen(
    state: SearchState,
    onQueryChange: (String) -> Unit
) {
    // 전달받은 상태에 따라 UI를 그립니다.
    RecipeList(recipes = state.filteredRecipes)

    // 전달받은 콜백을 SearchBar에 넘겨줍니다.
    SearchBar(onQueryChange = onQueryChange)
}
```

## 4. `Root`의 책임

`Root` 컴포저블은 다음과 같은 역할을 담당하여 `Screen`을 순수하게 유지합니다.

-   **의존성 주입**: `ViewModel` 주입
-   **상태 관리**: `State`를 구독하여 `Screen`에 전달
-   **화면 이동**: `Navigation` 처리
-   **일회성 이벤트 처리**: `Dialog`, `Snackbar` 표시
-   **초기화 로직**: `Lifecycle` 이벤트 처리, `remember`를 사용한 초기화
-   **외부 시스템 연동**: 권한 요청 등
-   `Preview`나 UI 테스트를 방해하는 모든 로직

## 5. 결론

`Root`와 `Screen`을 분리하는 아키텍처는 다음과 같은 장점을 제공합니다.

-   **테스트 용이성 극대화**: 순수한 UI인 `Screen`은 다양한 상태에 대해 쉽게 테스트할 수 있습니다.
-   **Preview 활용 극대화**: `@Preview` 어노테이션을 통해 `Screen`의 다양한 UI 상태를 시각적으로 확인할 수 있습니다.
-   **상태 관리 라이브러리 교체 비용 최소화**: `ViewModel`과의 결합도가 낮아져 다른 상태 관리 솔루션으로 쉽게 전환할 수 있습니다.
-   **UI 작성의 일관성 유지**: 모든 `Screen`이 상태와 콜백을 받는 일관된 방식으로 작성되어 코드의 가독성과 유지보수성이 향상됩니다.

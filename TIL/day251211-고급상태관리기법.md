# 고급 상태 관리 기법

이 문서는 Jetpack Compose의 고급 상태 관리 기법을 다룹니다. 먼저 핵심 내용을 간결하게 요약하고, 이어서 각 주제를 심도 있게 다루는 상세 가이드를 제공합니다.

---

## 1. 핵심 요약 (My Original Notes)

### 기본 문제점

- Screen이 ViewModel에 직접 의존
- UI 테스트와 Preview 작성 어려움
- 상태 관리 라이브러리 교체 어려움
- 테스트 작성 시간 증가
- 재사용성 낮음
- 컴포넌트 수준 테스트만 가능 → 화면 단위 테스트 불가

### 솔루션: Root와 Screen 분리

- 외부 의존성을 Screen에서 분리
- Screen을 순수 UI로 유지하여 테스트 가능성 및 재사용성 향상

### Screen에서 하면 안 되는 것

- ViewModel 인스턴스 접근
- Repository 등을 직접 호출
- 화면 이동
- 비즈니스 로직 포함

### Screen의 역할: 상태와 콜백만 사용

```kotlin
@Composable
fun SearchRecipesScreen(
    state: SearchRecipesState,
    onQueryChange: (String) -> Unit,
    onSearch: () -> Unit,
) {
    RecipeList(recipes = state.recipes)
    SearchBar(onQueryChange, onSearch)
}
```

### Root의 역할: 외부 래퍼

- ViewModel 주입, 상태 구독, 화면 이동 등 외부 의존성 처리 담당
- Root는 UI 테스트에서 제외 (필요시 별도 통합 테스트로 검증)

### Before vs After

**Before: ViewModel 직접 의존**
```kotlin
@Composable
fun SearchRecipesScreen(viewModel: SearchViewModel = viewModel()) {
    val state by viewModel.state.collectAsState()
    RecipeList(recipes = state.filteredRecipes)
    SearchBar(onQueryChange = { viewModel.onQueryChanged(it) })
}
```

**After: Root와 Screen 분리**
```kotlin
@Composable
fun SearchRecipesRoot(viewModel: SearchViewModel = viewModel()) {
    val state by viewModel.state.collectAsState()
    SearchRecipesScreen(
        state = state,
        onQueryChange = viewModel::onQueryChanged
    )
}

@Composable
fun SearchRecipesScreen(
    state: SearchState,
    onQueryChange: (String) -> Unit
) {
    RecipeList(recipes = state.filteredRecipes)
    SearchBar(onQueryChange = onQueryChange)
}
```

### Root의 책임 정리
- ViewModel 의존성 주입
- State 구독하여 Screen에 전달
- 화면 이동 처리
- Dialog / Snackbar 등 1회성 이벤트 처리
- Lifecycle, remember 등 초기화 처리
- 권한 요청 등 외부 시스템 연결

### 최종 정리
- **Screen**: 상태 + 콜백만을 가진 “순수 UI”
- **Root**: ViewModel, Navigation 등 외부 의존성 책임
- **장점**: 테스트 용이성, Preview 활용 극대화, 상태 관리 교체 비용 최소화, UI 작성 일관성 유지

---

## 2. 상세 가이드 (보강된 내용)

### 2.1. 문제점 상세: UI와 비즈니스 로직의 결합

일반적으로 Composable `Screen`이 `ViewModel`에 직접 의존하는 구조는 구현이 간단하지만, 애플리케이션이 복잡해질수록 다음과 같은 문제점을 야기합니다.

-   **UI 테스트의 어려움**: `ViewModel`의 의존성을 모의(mock) 처리하기 어려워 UI 테스트 및 `@Preview` 작성이 복잡해집니다.
-   **상태 관리 라이브러리 교체 비용 증가**: `ViewModel`과 `Screen`이 강하게 결합되어 있어, 다른 상태 관리 라이브러리로 교체하기 어렵습니다.
-   **낮은 재사용성**: 특정 `ViewModel`에 의존하는 `Screen`은 다른 컨텍스트에서 재사용하기 어렵습니다.
-   **제한적인 테스트 범위**: 화면 단위의 통합 테스트가 어려워지고, 컴포넌트 수준의 단편적인 테스트만 가능해집니다.

### 2.2. 해결책: 단방향 데이터 흐름(UDF) 기반 아키텍처

이러한 문제들을 해결하기 위해 **단방향 데이터 흐름(Unidirectional Data Flow, UDF)** 원칙에 따라 `Root`와 `Screen`의 역할을 명확히 분리하는 아키텍처를 제안합니다.

-   **State (상태)**: `ViewModel`에서 UI로, 즉 **아래 방향**으로 흐릅니다. UI는 이 상태를 관찰하고 화면을 그립니다.
-   **Event (이벤트)**: `Screen`에서 `ViewModel`로, 즉 **위쪽 방향**으로 흐릅니다. 사용자 상호작용과 같은 이벤트는 UI에서 발생하여 `ViewModel`로 전달됩니다.

이 구조에서 `Screen`은 외부 의존성 없이 오직 상태를 받아 UI를 그리고, 이벤트를 상위로 전달하는 역할만 하는 **순수 UI**로 남게 됩니다.

### 2.3. Sealed Class를 이용한 이벤트 캡슐화

`Screen`에서 발생하는 다양한 사용자 이벤트를 체계적으로 관리하기 위해 `Sealed Class`를 활용할 수 있습니다. 이렇게 하면 `Screen`은 단 하나의 콜백(`onEvent`)만을 가지게 되어 구조가 단순해지고, `ViewModel`은 `when` 표현식으로 이벤트를 명확하게 처리할 수 있습니다.

```kotlin
// 화면에서 발생할 수 있는 모든 이벤트를 Sealed Class로 정의합니다.
sealed class SearchEvent {
    data class QueryChanged(val query: String) : SearchEvent()
    data object SearchTriggered : SearchEvent()
    data class RecipeClicked(val recipeId: String) : SearchEvent()
}

// Screen은 이제 단 하나의 onEvent 콜백만 필요로 합니다.
@Composable
fun SearchRecipesScreen(
    state: SearchState,
    onEvent: (SearchEvent) -> Unit,
) {
    SearchBar(
        query = state.query,
        onQueryChange = { onEvent(SearchEvent.QueryChanged(it)) },
        onSearch = { onEvent(SearchEvent.SearchTriggered) }
    )
    RecipeList(
        recipes = state.recipes,
        onRecipeClick = { onEvent(SearchEvent.RecipeClicked(it.id)) }
    )
}

// ViewModel은 when을 사용하여 이벤트를 처리합니다.
class SearchViewModel : ViewModel() {
    fun onEvent(event: SearchEvent) {
        when (event) {
            is SearchEvent.QueryChanged -> onQueryChanged(event.query)
            is SearchEvent.SearchTriggered -> onSearch()
            is SearchEvent.RecipeClicked -> onRecipeClicked(event.recipeId)
        }
    }
    // ...
}
```

### 2.4. 일회성 이벤트 처리 (One-Time Events)

"검색 완료"와 같은 메시지를 `Snackbar`로 보여주거나 다른 화면으로 이동하는 것과 같은 이벤트는 **한 번만 실행**되어야 합니다. 만약 이러한 일회성 이벤트를 일반 `State`로 관리하면, 화면 회전과 같은 설정 변경 시 `State`가 유지되면서 이벤트가 불필요하게 다시 실행되는 문제가 발생합니다.

이 문제는 `SharedFlow` 또는 `Channel`을 사용하여 해결할 수 있습니다. `ViewModel`은 이벤트를 `Flow`로 노출하고, `Root` 컴포저블은 `LaunchedEffect`를 사용하여 이 `Flow`를 구독하고 이벤트를 처리합니다.

```kotlin
// ViewModel: 일회성 이벤트를 처리하기 위한 SharedFlow를 정의합니다.
class SearchViewModel : ViewModel() {
    private val _oneTimeEvent = MutableSharedFlow<OneTimeSearchEvent>()
    val oneTimeEvent = _oneTimeEvent.asSharedFlow()

    fun onSearch() {
        // ... 검색 로직 실행 ...
        viewModelScope.launch {
            _oneTimeEvent.emit(OneTimeSearchEvent.ShowSnackbar("검색 완료!"))
        }
    }
}

sealed class OneTimeSearchEvent {
    data class ShowSnackbar(val message: String) : OneTimeSearchEvent()
    data class NavigateToDetail(val recipeId: String): OneTimeSearchEvent()
}


// Root: LaunchedEffect를 사용하여 일회성 이벤트를 구독하고 처리합니다.
@Composable
fun SearchRecipesRoot(
    viewModel: SearchViewModel = viewModel(),
    scaffoldState: ScaffoldState = rememberScaffoldState(),
    navController: NavController = rememberNavController()
) {
    val state by viewModel.state.collectAsState()

    // 일회성 이벤트를 처리합니다.
    LaunchedEffect(viewModel) {
        viewModel.oneTimeEvent.collect { event ->
            when (event) {
                is OneTimeSearchEvent.ShowSnackbar -> {
                    scaffoldState.snackbarHostState.showSnackbar(event.message)
                }
                is OneTimeSearchEvent.NavigateToDetail -> {
                    navController.navigate("recipe/${event.recipeId}")
                }
            }
        }
    }

    SearchRecipesScreen(
        state = state,
        onEvent = viewModel::onEvent
    )
}

```

### 2.5. 최종 아키텍처 및 결론

`Root`와 `Screen`을 분리하고 단방향 데이터 흐름을 따르는 아키텍처는 다음과 같은 강력한 장점을 제공합니다.

-   **테스트 용이성 극대화**: 순수한 UI인 `Screen`은 다양한 상태에 대해 쉽게 Preview하고 단위 테스트를 작성할 수 있습니다.
-   **재사용성 및 유지보수성 향상**: UI 로직과 비즈니스 로직이 분리되어 코드를 이해하고 수정하기 쉬워집니다. `Screen`은 다른 `ViewModel`이나 컨텍스트에서도 재사용될 수 있습니다.
-   **상태 관리의 유연성**: `ViewModel`과의 결합도가 낮아져, 필요에 따라 다른 상태 관리 라이브러리(MVI, Orbit 등)로 쉽게 전환할 수 있습니다.
-   **UI 작성의 일관성**: 모든 `Screen`이 상태와 이벤트를 기반으로 작성되어, 프로젝트 전체의 코드 일관성을 유지하고 협업을 용이하게 합니다.

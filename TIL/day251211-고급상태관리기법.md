# Jetpack Compose 고급 상태 관리 가이드

이 문서는 Jetpack Compose에서 고급 상태 관리 기법, 특히 `Root`와 `Screen` 컴포저블을 분리하여 UI의 테스트 용이성, 재사용성, 그리고 유지보수성을 높이는 방법을 설명합니다. 단방향 데이터 흐름(UDF)을 기반으로, `Sealed Class`를 활용한 이벤트 캡슐화와 일회성 이벤트 처리까지 다루어, 초급 개발자부터 숙련된 개발자까지 모두에게 유용한 가이드가 되는 것을 목표로 합니다.

## 1. 문제점: UI와 비즈니스 로직의 결합

일반적으로 Composable `Screen`이 `ViewModel`에 직접 의존하는 구조는 구현이 간단하지만, 애플리케이션이 복잡해질수록 다음과 같은 문제점을 야기합니다.

-   **UI 테스트의 어려움**: `ViewModel`의 의존성을 모의(mock) 처리하기 어려워 UI 테스트 및 `@Preview` 작성이 복잡해집니다.
-   **상태 관리 라이브러리 교체 비용 증가**: `ViewModel`과 `Screen`이 강하게 결합되어 있어, 다른 상태 관리 라이브러리로 교체하기 어렵습니다.
-   **낮은 재사용성**: 특정 `ViewModel`에 의존하는 `Screen`은 다른 컨텍스트에서 재사용하기 어렵습니다.
-   **제한적인 테스트 범위**: 화면 단위의 통합 테스트가 어려워지고, 컴포넌트 수준의 단편적인 테스트만 가능해집니다.

## 2. 해결책: 단방향 데이터 흐름(UDF) 기반의 아키텍처

이러한 문제들을 해결하기 위해 **단방향 데이터 흐름(Unidirectional Data Flow, UDF)** 원칙에 따라 `Root`와 `Screen`의 역할을 명확히 분리하는 아키텍처를 제안합니다.

-   **State (상태)**: `ViewModel`에서 UI로, 즉 **아래 방향**으로 흐릅니다. UI는 이 상태를 관찰하고 화면을 그립니다.
-   **Event (이벤트)**: `Screen`에서 `ViewModel`로, 즉 **위쪽 방향**으로 흐릅니다. 사용자 상호작용과 같은 이벤트는 UI에서 발생하여 `ViewModel`로 전달됩니다.

<br>

이 구조에서 `Screen`은 외부 의존성 없이 오직 상태를 받아 UI를 그리고, 이벤트를 상위로 전달하는 역할만 하는 **순수 UI**로 남게 됩니다.

-   **Screen (순수 UI)**: `State`와 `Event Callback`만을 파라미터로 받아 UI를 렌더링합니다. `ViewModel`이나 다른 비즈니스 로직에 직접 접근하지 않습니다.
-   **Root (래퍼)**: `ViewModel` 주입, 상태 구독, 화면 이동, 일회성 이벤트 처리 등 모든 외부 의존성 처리를 담당하는 외부 래퍼(wrapper) 역할을 합니다.

### 2.1. Sealed Class를 이용한 이벤트 캡슐화

`Screen`에서 발생하는 다양한 사용자 이벤트를 체계적으로 관리하기 위해 `Sealed Class`를 활용할 수 있습니다. 이렇게 하면 `Screen`은 단 하나의 콜백(`onEvent`)만을 가지게 되어 구조가 단순해지고, `ViewModel`은 `when` 표현식으로 이벤트를 명확하게 처리할 수 있습니다.

```kotlin
// 화면에서 발생할 수 있는 모든 이벤트를 Sealed Class로 정의합니다.
sealed class SearchEvent {
    data class QueryChanged(val query: String) : SearchEvent()
    data object SearchTriggered : SearchEvent()
    data class RecipeClicked(val recipeId: String) : SearchEvent()
}

// Screen은 이제 단 하나의 onEvent 콜백만 필요로 합니다.
@Composable
fun SearchRecipesScreen(
    state: SearchState,
    onEvent: (SearchEvent) -> Unit,
) {
    SearchBar(
        query = state.query,
        onQueryChange = { onEvent(SearchEvent.QueryChanged(it)) },
        onSearch = { onEvent(SearchEvent.SearchTriggered) }
    )
    RecipeList(
        recipes = state.recipes,
        onRecipeClick = { onEvent(SearchEvent.RecipeClicked(it.id)) }
    )
}

// ViewModel은 when을 사용하여 이벤트를 처리합니다.
class SearchViewModel : ViewModel() {
    fun onEvent(event: SearchEvent) {
        when (event) {
            is SearchEvent.QueryChanged -> onQueryChanged(event.query)
            is SearchEvent.SearchTriggered -> onSearch()
            is SearchEvent.RecipeClicked -> onRecipeClicked(event.recipeId)
        }
    }
    // ...
}
```

### 2.2. 일회성 이벤트 처리 (One-Time Events)

"검색 완료"와 같은 메시지를 `Snackbar`로 보여주거나 다른 화면으로 이동하는 것과 같은 이벤트는 **한 번만 실행**되어야 합니다. 만약 이러한 일회성 이벤트를 일반 `State`로 관리하면, 화면 회전과 같은 설정 변경 시 `State`가 유지되면서 이벤트가 불필요하게 다시 실행되는 문제가 발생합니다.

이 문제는 `SharedFlow` 또는 `Channel`을 사용하여 해결할 수 있습니다. `ViewModel`은 이벤트를 `Flow`로 노출하고, `Root` 컴포저블은 `LaunchedEffect`를 사용하여 이 `Flow`를 구독하고 이벤트를 처리합니다.

```kotlin
// ViewModel: 일회성 이벤트를 처리하기 위한 SharedFlow를 정의합니다.
class SearchViewModel : ViewModel() {
    private val _oneTimeEvent = MutableSharedFlow<OneTimeSearchEvent>()
    val oneTimeEvent = _oneTimeEvent.asSharedFlow()

    fun onSearch() {
        // ... 검색 로직 실행 ...
        viewModelScope.launch {
            _oneTimeEvent.emit(OneTimeSearchEvent.ShowSnackbar("검색 완료!"))
        }
    }
}

sealed class OneTimeSearchEvent {
    data class ShowSnackbar(val message: String) : OneTimeSearchEvent()
    data class NavigateToDetail(val recipeId: String): OneTimeSearchEvent()
}


// Root: LaunchedEffect를 사용하여 일회성 이벤트를 구독하고 처리합니다.
@Composable
fun SearchRecipesRoot(
    viewModel: SearchViewModel = viewModel(),
    scaffoldState: ScaffoldState = rememberScaffoldState(),
    navController: NavController = rememberNavController()
) {
    val state by viewModel.state.collectAsState()

    // 일회성 이벤트를 처리합니다.
    // key1이 viewModel로 설정되어 ViewModel이 변경되어도 코루틴이 유지됩니다.
    LaunchedEffect(viewModel) {
        viewModel.oneTimeEvent.collect { event ->
            when (event) {
                is OneTimeSearchEvent.ShowSnackbar -> {
                    scaffoldState.snackbarHostState.showSnackbar(event.message)
                }
                is OneTimeSearchEvent.NavigateToDetail -> {
                    navController.navigate("recipe/${event.recipeId}")
                }
            }
        }
    }

    SearchRecipesScreen(
        state = state,
        onEvent = viewModel::onEvent
    )
}

```

## 3. 최종 아키텍처 요약

-   **ViewModel**: 비즈니스 로직을 처리하고, UI 상태(`StateFlow`)와 일회성 이벤트(`SharedFlow`)를 노출합니다. UI로부터는 `Event`를 받아 처리합니다.
-   **Root Composable**: `ViewModel`과 상호작용하며 상태와 이벤트를 처리하는 컨테이너입니다. `State`를 `Screen`에 전달하고, `Screen`의 `Event`를 `ViewModel`로 전달하며, 일회성 이벤트를 처리합니다.
-   **Screen Composable**: 오직 `State`를 받아 UI를 그리고, 사용자 상호작용을 `Event`로 만들어 상위로 전달하는 순수 UI 컴포저블입니다.

## 4. 결론: 왜 이 아키텍처를 사용해야 하는가?

`Root`와 `Screen`을 분리하고 단방향 데이터 흐름을 따르는 아키텍처는 다음과 같은 강력한 장점을 제공합니다.

-   **테스트 용이성 극대화**: 순수한 UI인 `Screen`은 다양한 상태에 대해 쉽게 Preview하고 단위 테스트를 작성할 수 있습니다.
-   **재사용성 및 유지보수성 향상**: UI 로직과 비즈니스 로직이 분리되어 코드를 이해하고 수정하기 쉬워집니다. `Screen`은 다른 `ViewModel`이나 컨텍스트에서도 재사용될 수 있습니다.
-   **상태 관리의 유연성**: `ViewModel`과의 결합도가 낮아져, 필요에 따라 다른 상태 관리 라이브러리(MVI, Orbit 등)로 쉽게 전환할 수 있습니다.
-   **UI 작성의 일관성**: 모든 `Screen`이 상태와 이벤트를 기반으로 작성되어, 프로젝트 전체의 코드 일관성을 유지하고 협업을 용이하게 합니다.

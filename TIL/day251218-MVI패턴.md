# MVI 패턴

- Model - View - Intent
- Intent : 사용자 액션, 사용자가 UI에서 발생시키는 액션 (버튼 클릭, 텍스트 입력 등)
- 복잡한 상태관리에 유용한 패턴

## MVI의 핵심 구성 요소

MVI 패턴은 세 가지 주요 컴포넌트로 구성됩니다

- **Model**: UI에 반영될 상태(State)를 의미하며, 불변(immutable) 데이터 구조로 관리됩니다. 상태가 변경되면 기존 객체를 직접 수정하지 않고 새로운 상태
  객체를 생성합니다.
- **View**: 사용자에게 보여지는 UI 화면으로, Activity, Fragment, Jetpack Compose 등이 해당됩니다. View는 비즈니스 로직을 처리하지 않고
  Model의 상태를 관찰하여 화면을 렌더링합니다.
- **Intent**: 버튼 클릭, 텍스트 입력과 같은 사용자 액션이나 시스템 이벤트를 나타냅니다. 이는 Android의 `Intent` 클래스와는 다른 개념으로, 사용자의
  의도를 캡처하여 Model에 전달하는 역할을 합니다.

## 데이터 흐름 방식

MVI의 단방향 데이터 흐름은 다음과 같이 작동합니다:

사용자가 View에서 버튼을 클릭하면 Intent가 발생하고, ViewModel은 이 Intent를 받아 Reducer를 호출합니다. Reducer는 이전 상태와 Intent를
기반으로 새로운 불변 State를 생성하며, View는 변경된 State를 관찰하여 UI를 업데이트합니다. 이러한 순환 구조 덕분에 데이터 흐름을 추적하기 쉽고 디버깅이
용이합니다.

## 간단한 MVI 예제 (카운터 앱)

MVI 패턴을 이해하는 데 도움이 되는 간단한 카운터 앱 예제입니다.

### 1. State 정의

상태(State)는 UI에 표시될 데이터를 포함하는 불변 객체입니다.

```kotlin
data class CounterState(val count: Int = 0)
```

### 2. Intent 정의

인텐트(Intent)는 사용자의 액션을 나타냅니다.

```kotlin
sealed class CounterIntent {
    object Increment : CounterIntent()
}
```

### 3. ViewModel 구현

ViewModel은 Intent를 받아 상태를 업데이트하고, View가 관찰할 수 있는 State를 노출합니다.

```kotlin
import androidx.lifecycle.ViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

class CounterViewModel : ViewModel() {

    private val _state = MutableStateFlow(CounterState())
    val state: StateFlow<CounterState> = _state.asStateFlow()

    fun handleIntent(intent: CounterIntent) {
        when (intent) {
            is CounterIntent.Increment -> {
                _state.value = _state.value.copy(count = _state.value.count + 1)
            }
        }
    }
}
```

### 4. View 구현 (Jetpack Compose)

View는 ViewModel의 상태를 관찰하여 UI를 렌더링하고, 사용자 입력을 Intent로 변환하여 ViewModel에 전달합니다.

```kotlin
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.Button
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.sp
import androidx.lifecycle.viewmodel.compose.viewModel

@Composable
fun CounterScreen(viewModel: CounterViewModel = viewModel()) {
    val state by viewModel.state.collectAsState()

    Column(
        modifier = Modifier.fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(text = "Count: ${state.count}", fontSize = 24.sp)
        Button(onClick = { viewModel.handleIntent(CounterIntent.Increment) }) {
            Text("Increment")
        }
    }
}
```

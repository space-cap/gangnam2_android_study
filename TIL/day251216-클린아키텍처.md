# 클린 아키텍처

## 대형 앱으로 갈 수록 고민이 많아짐

- ViewModel 코드가 너무 길어짐
- 중복 코드가 생김
- 재사용하기 어려움

복잡도를 줄이고 읽기 쉬운 구조가 필요하다.

## 소프트웨어 가치

- 행위 가치
  - 기능이 잘 작동하는가?
- 구조 가치
  - 구조가 잘 짜여져 있는가?

기능만 잘 만들고 구조를 신경 안 쓰면, 나중에 수정하거나 확장하기 어렵다.

## 클린 아키텍처란?

- 저자 : 로버트 C. 마틴 (Clean Architecture, 2012)
- 핵심 개념들
  - 단일 책임 원칙 (SRP)
  - 의존성 역전 원칙 (DIP)
  - 계층 간 명확한 분리
- 계속 발전하고 있으며, 소프트웨어 아키텍처 설계의 핵심 원칙 중 하나로 인정받고 있음

## 안드로이드에서의 클린 아키텍처: 도메인 레이어

안드로이드 공식 문서에서는 UI 레이어와 데이터 레이어 사이에 **도메인 레이어(Domain Layer)** 라는 선택적 레이어를 제안합니다. 이는 클린 아키텍처의 개념을 차용한 것입니다.

![Domain Layer Overview](https://developer.android.com/static/topic/libraries/architecture/images/mad-arch-domain-overview.png)

### 도메인 레이어의 역할과 장점

도메인 레이어는 복잡한 비즈니스 로직이나 여러 ViewModel에서 재사용되는 간단한 비즈니스 로직을 캡슐화하는 역할을 합니다. 모든 앱에 필요한 것은 아니며, 복잡성을 다루거나 재사용성을 높이고 싶을 때 사용합니다.

- **코드 중복 방지**: 여러 ViewModel에서 동일한 로직을 공유할 수 있습니다.
- **가독성 향상**: ViewModel의 코드가 간결해지고 비즈니스 로직을 쉽게 파악할 수 있습니다.
- **테스트 용이성 향상**: 비즈니스 로직을 독립적으로 테스트할 수 있습니다.
- **클래스 크기 감소**: 책임을 분리하여 거대한 클래스가 만들어지는 것을 방지합니다.

### 유즈케이스 (Use Cases)

도메인 레이어의 핵심 구성요소는 **유즈케이스(Use Case)** 입니다. 각 유즈케이스는 단일 기능을 책임져야 합니다.

- **네이밍 컨벤션**: `현재 시제 동사` + `명사/무엇을 (선택)` + `UseCase` (예: `FormatDateUseCase`, `GetLatestNewsWithAuthorsUseCase`)
- **의존성**: 유즈케이스는 보통 데이터 레이어의 **저장소(Repository)** 에 의존합니다.
- **코틀린에서의 활용**: `operator fun invoke()`를 사용하여 유즈케이스 인스턴스를 함수처럼 호출할 수 있습니다.

```kotlin
class FormatDateUseCase(userRepository: UserRepository) {
    private val formatter = SimpleDateFormat(
        userRepository.getPreferredDateFormat(),
        userRepository.getPreferredLocale()
    )

    operator fun invoke(date: Date): String {
        return formatter.format(date)
    }
}

// ViewModel에서 호출
val todaysDate = formatDateUseCase(Calendar.getInstance())
```

- **스레딩**: 유즈케이스는 `main-safe` 해야 합니다. 즉, 메인 스레드에서 호출해도 안전해야 합니다. 오래 걸리는 작업은 백그라운드 스레드로 옮겨야 합니다.

### 주요 작업

1.  **재사용 가능한 간단한 비즈니스 로직**: UI 레이어에 반복적으로 나타나는 로직을 유즈케이스로 캡슐화합니다. (예: 날짜 포맷팅)
2.  **저장소 결합**: 여러 저장소에서 데이터를 가져와 조합하는 로직을 처리합니다. 예를 들어, 뉴스 정보와 작성자 정보를 별도의 저장소에서 가져와 합치는 경우에 유용합니다.

# DI(의존성 주입) - 쉽고 자세한 설명

## 1. 의존성 주입(DI)이란 무엇일까요?

"DI는 **'필요한 부품(객체)을 외부에서 넣어주는 것'**입니다."

DI(Dependency Injection)는 **객체가 필요로 하는 다른 객체(의존성)를 직접 만들지 않고, 외부에서 전달받아 사용**하는 디자인 패턴입니다.

**예시: 자동차와 타이어**

- **DI가 없는 경우:** 자동차가 직접 타이어를 생산합니다. 타이어가 펑크나면 자동차 공장 전체를 멈추고 타이어를 교체해야 합니다. 다른 종류의 타이어를 사용하기도 어렵습니다.
- **DI가 있는 경우:** 자동차는 외부에서 이미 만들어진 타이어를 장착합니다. 타이어가 펑크나면 해당 타이어만 교체하면 됩니다. 스포츠 타이어, 겨울용 타이어 등 원하는 타이어로 쉽게 교체할 수 있습니다.

이처럼 DI를 사용하면 **객체 간의 결합도를 낮춰** 코드를 더 유연하고 테스트하기 쉽게 만들 수 있습니다.

## 2. 왜 의존성 주입을 사용해야 할까요? (장점)

- **테스트 용이성**: 실제 객체 대신 **가짜 객체(Mock)를 주입**하여 특정 기능만 독립적으로 테스트할 수 있습니다. 예를 들어, 네트워크 통신이 필요한 부분을 테스트할 때 실제 네트워크 요청 없이 가짜 데이터를 주입하여 테스트할 수 있습니다.
- **유연성 및 재사용성**: 부품처럼 쉽게 교체할 수 있어 코드 수정이 용이합니다. `A`라는 데이터베이스를 사용하다가 `B` 데이터베이스로 변경할 때, 해당 부분을 쉽게 교체할 수 있습니다.
- **결합도 감소 (느슨한 결합)**: 객체들이 서로에게 직접적으로 의존하지 않으므로, 한 객체의 변경이 다른 객체에 미치는 영향을 최소화할 수 있습니다.
- **코드의 가독성 향상**: 객체가 어떤 의존성을 필요로 하는지 명확하게 파악할 수 있습니다.

## 3. 의존성 주입 예제: ViewModel

`SavedRecipesViewModel`의 실제 코드를 통해 DI가 없는 경우와 있는 경우를 비교해 보겠습니다.

**의존성 관계:** `ViewModel` → `UseCase` → `Repository` → `DataSource`

### 3.1. DI가 없는 경우 (나쁜 예)

모든 객체를 내부에서 직접 생성합니다. 각 클래스가 하위 클래스에 강하게 결합되어 있습니다.

```kotlin
// ViewModel이 UseCase를 직접 생성
class SavedRecipesViewModel : ViewModel() {
    // 내부에서 직접 의존성을 생성하고 있습니다.
    private val getSavedRecipesUseCase = GetSavedRecipesUseCase()

    // ...
}

// UseCase가 Repository를 직접 생성
class GetSavedRecipesUseCase {
    // 내부에서 직접 의존성을 생성하고 있습니다.
    private val recipeRepository = RecipeRepositoryImpl()

    suspend operator fun invoke(): List<Recipe> {
        return recipeRepository.getRecipes()
    }
}

// Repository가 DataSource를 직접 생성
class RecipeRepositoryImpl : RecipeRepository {
    // 내부에서 직접 의존성을 생성하고 있습니다.
    private val recipeDataSource = RecipeDataSourceImpl()

    override suspend fun getRecipes(): List<Recipe> {
        return recipeDataSource.getRecipes().map { it.toRecipe() }
    }
}

// DataSource는 의존성이 없음
class RecipeDataSourceImpl : RecipeDataSource {
    override suspend fun getRecipes(): List<RecipeDto> {
        // ... 레시피 데이터를 가져오는 코드
    }
}
```

**문제점:**
- **테스트의 어려움:** `SavedRecipesViewModel`을 테스트하려면 `GetSavedRecipesUseCase`, `RecipeRepositoryImpl`, `RecipeDataSourceImpl`이 모두 필요합니다. `RecipeDataSourceImpl`이 실제 네트워크나 데이터베이스에 접근한다면 단위 테스트가 매우 힘들어집니다.
- **유연성 부족:** `RecipeRepositoryImpl`을 다른 구현체(예: `TestRecipeRepositoryImpl`)로 바꾸려면 `GetSavedRecipesUseCase`의 코드를 직접 수정해야 합니다.

### 3.2. 수동 의존성 주입 (좋은 예)

객체 생성의 책임을 외부로 옮기고, 생성자(Constructor)를 통해 의존성을 주입합니다.

```kotlin
// Activity/Fragment에서 의존성을 생성하고 ViewModel에 주입합니다.
// 실제 앱에서는 DI 컨테이너(Hilt, Koin 등)가 이 역할을 대신합니다.
val dataSource = RecipeDataSourceImpl()
val repository = RecipeRepositoryImpl(dataSource)
val useCase = GetSavedRecipesUseCase(repository)
val viewModel = SavedRecipesViewModel(useCase)


// ViewModel은 UseCase를 외부에서 주입받습니다.
class SavedRecipesViewModel(
    private val getSavedRecipesUseCase: GetSavedRecipesUseCase,
) : ViewModel() {
    // ...
}

// UseCase는 Repository 인터페이스를 외부에서 주입받습니다.
class GetSavedRecipesUseCase(
    private val recipeRepository: RecipeRepository // 구체적인 구현이 아닌 인터페이스에 의존
) {
    suspend operator fun invoke(): List<Recipe> {
        return recipeRepository.getRecipes()
    }
}

// Repository는 DataSource 인터페이스를 외부에서 주입받습니다.
class RecipeRepositoryImpl(
    private val recipeDataSource: RecipeDataSource // 구체적인 구현이 아닌 인터페이스에 의존
) : RecipeRepository {
    override suspend fun getRecipes(): List<Recipe> {
        return recipeDataSource.getRecipes().map { it.toRecipe() }
    }
}

// DataSource는 의존성이 없음
class RecipeDataSourceImpl : RecipeDataSource {
    override suspend fun getRecipes(): List<RecipeDto> {
        // ... 레시피 데이터를 가져오는 코드
    }
}
```

**개선된 점:**
- **테스트 용이성:** `SavedRecipesViewModel` 테스트 시, 실제 `GetSavedRecipesUseCase` 대신 가짜(Mock) UseCase를 쉽게 주입할 수 있습니다.
- **유연성 향상:** `RecipeRepositoryImpl`이 아닌 다른 `RecipeRepository` 구현체를 `GetSavedRecipesUseCase`에 주입할 수 있습니다. `UseCase` 코드를 수정할 필요가 없습니다.
- **의존성 역전 원칙(DIP) 준수:** `ViewModel`, `UseCase`, `Repository`가 구체적인 구현 클래스가 아닌 **추상화(인터페이스)에 의존**하게 되어 결합도가 낮아졌습니다.

## 4. 의존성 주입 라이브러리 (Hilt)

수동으로 의존성을 주입하는 것은 프로젝트가 커질수록 번거롭고 보일러플레이트 코드가 많아집니다. 이때 **Hilt**와 같은 DI 라이브러리를 사용하면 이 과정을 자동화할 수 있습니다.

Hilt는 `@Inject`, `@Module`, `@InstallIn` 같은 어노테이션을 사용하여 의존성을 정의하고 주입하는 방법을 제공하여, 우리가 직접 객체를 생성하고 연결해주던 작업을 대신 해줍니다.

### Hilt를 사용한 예제

```kotlin
// ViewModel에 @HiltViewModel 어노테이션을 추가하고,
// 생성자에 @Inject를 붙여주면 Hilt가 알아서 의존성을 주입해줍니다.
@HiltViewModel
class SavedRecipesViewModel @Inject constructor(
    private val getSavedRecipesUseCase: GetSavedRecipesUseCase,
) : ViewModel() {
    // ...
}

// UseCase, Repository, DataSource도 동일하게 @Inject를 사용하여 의존성을 주입받도록 설정합니다.
// (자세한 설정 방법은 Hilt 문서를 참고하세요)
```

Hilt를 사용하면 Activity/Fragment에서 `by viewModels()` 델리게이트를 통해 간단하게 ViewModel 인스턴스를 얻을 수 있으며, Hilt가 나머지 의존성을 모두 알아서 주입해줍니다.

## 5. 정리

- **의존성 주입(DI)**은 객체 간의 결합도를 낮춰 코드를 **유연하고 테스트하기 쉽게** 만드는 중요한 디자인 패턴입니다.
- DI를 사용하면 **의존성 역전 원칙(DIP)**을 자연스럽게 따르게 되어, 구체적인 구현이 아닌 **추상화(인터페이스)에 의존**하는 코드를 작성하게 됩니다.
- **Hilt**와 같은 DI 라이브러리는 DI 구현을 자동화하여 보일러플레이트 코드를 줄여주고 개발 생산성을 높여줍니다.

DI의 핵심 원리를 이해하고 라이브러리를 사용한다면, 더 효율적이고 유지보수하기 좋은 애플리케이션을 만들 수 있습니다.
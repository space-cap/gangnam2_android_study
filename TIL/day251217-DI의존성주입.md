# DI 의존성 주입

## 의존성 주입 개념

의존성 주입(Dependency Injection, DI)은 객체가 자신의 의존성을 직접 생성하지 않고 외부에서 제공받는 소프트웨어 디자인 패턴이다
"누가 준비해서 나에게 넣어줘!"

## 의존성 역전 원칙(Dependency Inversion Principle, DIP)

- 의존성 주입(DI)은 소프트웨어 디자인 원칙 중 "의존성 역전 원칙"을 구현하는 핵심임

- DIP의 핵심
  - 상위 수준 모듈은 하위 수준 모듈에 의존해서는 안 되며, 추상화에 의존해야 한다
  - 추상화는 구체적인 구현 세부 사항에 의존해서는 안 된다

- 기대 효과
  - ViewModel이 구체적인 RepositoryImpl 클래스가 아닌, 인터페이스에 의존하게 되어 결합도가 낮아짐
  - 쉽게 다른 구현체로 교체할 수 있고 테스트가 용이해 짐

## 의존성 주입의 장점

- 테스트 용이성: 모의 객체(mock)를 주입하여 단위 테스트 가능
- 유연성: 동일한 인터페이스를 구현한 다양한 구현체로 쉽게 교체 가능
- 결합도 감소: 컴포넌트 간 직접적인 의존성 제거
- 관심사 분리: 객체 생성과 사용의 책임 분리

## 의존성 등록 방식의 차이

- Singleton
  - 앱 시작시 1번만 생성됨
  - 예시 : Repository, DataSource, UseCase

- Factory
  - 필요할 때마다 새로 생성
  - 예시 : ViewModel

## ViewModel은 왜 Factory 인가

- 상태가 화면마다 다르기 때문에
  - ViewModel 은 화면 상태(UI State)를 관리
  - 각 화면마다 독립된 상태가 필요

- 의도하지 않은 상태 공유를 방지하기 위해
  - Singleton 으로 만들면 앱 전체에서 하나의 ViewModel만 사용됨
  - 상태가 섞이거나 꼬일 수 있음
  - A 화면에서 값이 바뀌면 B 화면에도 반영되서 버그 발생

## Repository 등은 왜 Singleton 인가

- 대부분 상태를 갖지 않는 기능 클래스이기 때문에
- 같은 기능은 계속 재사용하면 효율적
- 메모리도 아끼고, 빠르고 안정적

## Android 에서의 인존성 주입 라이브러리

- Dagger
  - 레거시, Java용

- Hilt
  - (Android 전용 - 대거 상위호환, Java 어노테이션 활용 - 컴파일 타임 안전, Google 주도)
  - 매직이 많음
  - KMP 대응
  - 취업하려면 써야 함

- Koin
  - (코틀린 전용 - 런타임 주입)
  - 직관적
  - 근본에 가까움
  - KMP 대응












